---
title: "AEF Mandatory Assignment 3"
author: "Alexander Mogensen, Mie Schjerling and Philip Hansen"
date: "7/5/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

########################
### BEGIN USER INPUT ###
######################## 

# Automatic setup for working directory for authors of this file
tmp <- getwd()
if(substr(tmp,1,12) == "C:/Users/Mie"){
  # Mie
  setwd("C:/Users/Mie/OneDrive/CBS/Kandidat/data")
} else if(substr(tmp,1,14) == "C:/Users/Alexm"){
  # Alexander
  setwd("C:/Users/Alexm/Documents")
} else{
  # Philip
  setwd("C:/Users/phili/OneDrive - CBS - Copenhagen Business School/Desktop/Code/R - code/AEF")
}

gamma_default <- 4

######################
### END USER INPUT ###
######################


# Load packages
library(lubridate)
library(sandwich)
library(lmtest)
library(RSQLite)
library(tidyverse)
library(tidymodels)
library(furrr)
library(glmnet)
library(broom)
library(timetk)
library(scales)
library(keras)
library(hardhat)
library(kableExtra)
library(data.table)
library(ranger)

# Changes decimals from having e to having 0s
options(scipen = 999)

# Loading data
tidy_finance <- dbConnect(SQLite(), "tidy_finance.sqlite", extended_types = TRUE) # Connect to sql
crsp_monthly <- tbl(tidy_finance, "crsp_monthly") %>% collect() %>% select("permno", "date", "month", "ret", "mktcap", "mktcap_lag", "industry", "ret_excess")

```

```{r excersise 1: filtration of data, echo=FALSE}
# Filtering on desired time interval for uninterrupted stocks
crsp_monthly_reduced <- crsp_monthly[crsp_monthly$permno %in% (intersect(crsp_monthly %>% filter(month=="1962-01-01") %>% select(permno),crsp_monthly %>% filter(month=="2019-12-01") %>% select(permno)))$permno,]
```





```{r excersise 2: compute optimal weights, echo=FALSE}
# Function that computes the optimal weights
optimal_weights <- function(w_prev, mu, Sigma, beta, gamma = gamma_default, B){
  N <- ncol(Sigma)
  iota <- rep(1, N)
  
  Sigma_proc <- Sigma + beta / gamma * diag(B) # Cost-adjusted sigma
  mu_proc <- mu + beta * diag(B) %*% w_prev # Cost-adjusted mu
  
  Sigma_inv <- solve(Sigma_proc) # invert Sigma 
  
  # Calculates the optimal weights
  w_mvp <- Sigma_inv %*% iota
  w_mvp <- w_mvp / sum(w_mvp)
  w_opt <- w_mvp  + 1/gamma * (Sigma_inv - w_mvp %*% t(iota) %*% Sigma_inv) %*% mu_proc
  return(w_opt)
}

```














