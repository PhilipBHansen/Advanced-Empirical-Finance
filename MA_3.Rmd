---
title: "AEF Mandatory Assignment 3"
author: "Alexander Mogensen, Mie Schjerling and Philip Hansen"
date: "7/5/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

########################
### BEGIN USER INPUT ###
######################## 

# Automatic setup for working directory for authors of this file
tmp <- getwd()
if(substr(tmp,1,12) == "C:/Users/Mie"){
  # Mie
  setwd("C:/Users/Mie/OneDrive/CBS/Kandidat/data")
} else if(substr(tmp,1,14) == "C:/Users/Alexm"){
  # Alexander
  setwd("C:/Users/Alexm/Documents")
} else{
  # Philip
  setwd("C:/Users/phili/OneDrive - CBS - Copenhagen Business School/Desktop/Code/R - code/AEF")
}

gamma_default <- 4

######################
### END USER INPUT ###
######################


# Load packages
library(lubridate)
library(sandwich)
library(lmtest)
library(RSQLite)
library(tidyverse)
library(tidymodels)
library(furrr)
library(glmnet)
library(broom)
library(timetk)
library(scales)
library(keras)
library(hardhat)
library(kableExtra)
library(data.table)
library(ranger)

# Changes decimals from having e to having 0s
options(scipen = 999)

# Loading data
tidy_finance <- dbConnect(SQLite(), "tidy_finance.sqlite", extended_types = TRUE) # Connect to sql
crsp_monthly <- tbl(tidy_finance, "crsp_monthly") %>% collect() %>% select("permno", "date", "month", "ret", "mktcap", "mktcap_lag", "industry", "ret_excess")

```

We find the stocks that are traded each month from 1962 until 2020, by counting the number of months in this interval, counting the number of times each stock (permno) is traded and then filtering on the stocks that are traded the same amount of times as there exists of month (which for this interval is `r n_months`). This results in an investment universe consisting of 119 stocks. We then create the following summary of the excess return.

```{r Exercise 1, echo=TRUE}
# Filtering on desired time interval for uninterrupted stocks
crsp_monthly_reduced <- crsp_monthly %>% 
  filter(month >= "1962-01-01") %>% 
  filter(month <= "2019-12-01") 

stocks_traded <- crsp_monthly_reduced %>% 
  group_by(permno) %>% 
  summarise(n=n())

n_months <- length(unique(crsp_monthly_reduced$month))

stocks_traded <- stocks_traded %>% filter(n == n_months)

crsp_monthly_reduced <- crsp_monthly_reduced %>%
  filter(permno %in% stocks_traded$permno)

# Creating summary statistics
crsp_monthly_reduced %>%
  group_by(month) %>%
  summarise(across(ret_excess, #Creating list of summarize statistics
                   list(mean = mean, sd = sd, min = min,
                        q25 = ~quantile(., 0.25),
                        median = median,
                        q75 = ~quantile(., 0.75), max = max),
                   .names = "{.fn} excess_ret")) %>% #Adds the name to every element in the list
  summarise(across(-month, mean)) %>%
knitr::kable(digits = 4)%>% kable_paper("hover", full_width = T) #creates a table to view the data.

```

We see that on average a equally weighted portfolio with all assets in our investment universe would have generated a 0.78% monthly return. We also see that on average the 25% worst performing stocks have generated a negative excess return of -3.38% or worse. While the 25% best performing stocks have generated a excess return of 4.57% or more.

```{r excersise 2: compute optimal weights, echo=FALSE}
# Function that computes the optimal weights
optimal_weights <- function(w_prev, mu, Sigma, lambda, gamma = gamma_default){
  N <- ncol(Sigma)
  iota <- rep(1, N)
  
  mu_star <- mu + 2 * lambda * Sigma %*% w_prev # Cost-adjusted mu
  Sigma_star <- (gamma + 2 * lambda) / gamma * Sigma # Cost-adjusted sigma
  
  Sigma_inv <- solve(Sigma_star) # invert Sigma 
  
  # Calculates the optimal portfolio weights
  w_mvp <- Sigma_inv %*% iota
  w_mvp <- w_mvp / sum(w_mvp)
  w_opt <- w_mvp  + 1/gamma * (Sigma_inv - w_mvp %*% t(iota) %*% Sigma_inv) %*% mu_star
  return(w_opt)
}

```

```{r excersise 2: compute sample mean and variance-covariance matrix, echo=FALSE}

# Computes sample mean excess return
mu <- (crsp_monthly_reduced %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess



# Computes sample variance-covariance matrix
stocks <- unique(crsp_monthly_reduced$permno)
returns <- matrix(ncol = length(stocks), nrow = n_months)
colnames(returns) <- stocks
for(i in 1:length(stocks)){
  returns[,i] <- (crsp_monthly_reduced %>% filter(permno == stocks[i]))$ret_excess
}

Sigma <- returns %>% cov() %>% as.matrix()


```



```{r excersise 3: Backtesting, echo=FALSE}
#Prepare vectors that contain results
N<-nrow(Sigma)
window_length<-12
months<-sort(unique(crsp_monthly_reduced$month))
periods<-17-window_length #Number of periods
NP_return<-rep(0,periods)
HEA_return<-rep(0,periods)
NSS_return<-rep(0,periods)

NP_turnover<-rep(0,periods)
HEA_turnover<-rep(0,periods)
NSS_turnover<-rep(0,periods)

NP_TC<-rep(0,periods)
HEA_TC<-rep(0,periods)
NSS_TC<-rep(0,periods)

test_mu<-rep(0,periods)

for(i in 1:(periods)){ #Begin for loop for monthly portfolio estimation
  

  #Chosse the part of the data frame that matches our window
  crsp_monthly_reduced_tmp<-crsp_monthly_reduced %>% filter(month %in% months[i:i+12])
  # Computes sample mean excess return
  mu_hat <- (crsp_monthly_reduced_tmp %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess

  # Computes sample variance-covariance matrix
  stocks <- unique(crsp_monthly_reduced$permno)
  returns <- matrix(ncol = length(stocks), nrow = n_months)
  colnames(returns) <- stocks
  for(j in 1:length(stocks)){
    returns[,j] <- (crsp_monthly_reduced_tmp %>% filter(permno == stocks[j]))$ret_excess
  }
  
  Sigma_hat <- returns %>% cov() %>% as.matrix()
  Sigma_hat
  
  sum(mu_hat)
  
  test_mu[i]<-sum(mu_hat)  
  
#Define lambda
lambda<-200/10000

#Calculate portfolio weights

  #Naive portfolio
   # NP<-rep(1/N,N)
   # NP_return_tmp<-t(NP) %*% mu_hat
  #Hautsch et al. portfolio
    #HEA<-....   Closed form fomula
   # HEA_return_tmp<-t(HEA) %*% mu_hat
  #Jagannathan portfolion
    # NSS<-...   No_short_sale_weight
   # NSS_return_tmp<-t(NSS) %*% mu_hat

  
  # calculate Transaction cost and turnover. Save them
 # NP_turnover[i]<-1
#  HEA_turnover[i]<-1
 # NSS_turnover[i]<-1
 #   
#  NP_TC[i]<-1
#  HEA_TC[i]<-1
#  NSS_TC[i]<-1

  #Calculate returns adjusted for transaction cost
 # NP_return<-NP_return_tmp-NP_TC[i]
 # HEA_return<-HEA_return_tmp-HEA_TC[i]
 # NSS_return<-NSS_return_tmp-NSS_TC[i]
      
  #Save portolio weigths lagged for turnover calculation in next month  
 # NP_lagged<-NP
#  HEA_lagged<-HEA
#  NSS_lagged<-NSS   
     
} #End loop

#Average turnover

#Sharpe ratio


test_mu

```












