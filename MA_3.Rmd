---
title: "AEF Mandatory Assignment 3"
author: "Alexander Mogensen, Mie Schjerling and Philip Hansen"
date: "7/5/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

########################
### BEGIN USER INPUT ###
######################## 

# Automatic setup for working directory for authors of this file
tmp <- getwd()
if(substr(tmp,1,12) == "C:/Users/Mie"){
  # Mie
  setwd("C:/Users/Mie/OneDrive/CBS/Kandidat/data")
} else if(substr(tmp,1,14) == "C:/Users/Alexm"){
  # Alexander
  setwd("C:/Users/Alexm/Documents")
} else{
  # Philip
  setwd("C:/Users/phili/OneDrive - CBS - Copenhagen Business School/Desktop/Code/R - code/AEF")
}

gamma_default <- 4
window_length<-240
lambda<-200/10000

######################
### END USER INPUT ###
######################


# Load packages
library(lubridate)
library(sandwich)
library(lmtest)
library(RSQLite)
library(tidyverse)
library(tidymodels)
library(furrr)
library(glmnet)
library(broom)
library(timetk)
library(scales)
library(keras)
library(hardhat)
library(kableExtra)
library(data.table)
library(ranger)

# Changes decimals from having e to having 0s
options(scipen = 999)

# Loading data
tidy_finance <- dbConnect(SQLite(), "tidy_finance.sqlite", extended_types = TRUE) # Connect to sql
crsp_monthly <- tbl(tidy_finance, "crsp_monthly") %>% collect() %>% select("permno", "date", "month", "ret", "mktcap", "mktcap_lag", "industry", "ret_excess")

```

```{r Exercise 1 data filtering, echo=FALSE}
# Filtering on desired time interval for uninterrupted stocks
crsp_monthly_reduced <- crsp_monthly %>% 
  filter(month >= "1962-01-01") %>% 
  filter(month <= "2019-12-01") 

stocks_traded <- crsp_monthly_reduced %>% 
  group_by(permno) %>% 
  summarise(n=n())

n_months <- length(unique(crsp_monthly_reduced$month))

stocks_traded <- stocks_traded %>% filter(n == n_months)

crsp_monthly_reduced <- crsp_monthly_reduced %>%
  filter(permno %in% stocks_traded$permno)

```

### Excercise 1
The data used for this assignment is collected from the CRSP universe and consists of data from 1962 until 2020. We only select the stocks that are traded each month during this time period. This is done by counting the number of months in this interval, counting the number of times each stock (permno) is traded and then filtering on the stocks that are traded the same amount of times as there exists of month (which for this interval is `r n_months`). This results in an investment universe consisting of 119 stocks. We then create the following summary of the excess return by finding the cross-sectional values for each month and then averaging over all month:

```{r Exercise 1 summary, echo=FALSE}
# Creating summary statistics
summary1 <- crsp_monthly_reduced %>%
  group_by(month) %>%
  summarise(across(ret_excess, #Creating list of summarize statistics
                   list(mean = mean, sd = sd, min = min,
                        q25 = ~quantile(., 0.25),
                        median = median,
                        q75 = ~quantile(., 0.75), max = max),
                   .names = "{.fn} excess_ret")) %>% #Adds the name to every element in the list
  summarise(across(-month, mean)) 

row.names(summary1) <- "Excess return"

summary1 %>%
  knitr::kable(booktabs = T, digits = 4, caption = "Summary statistics of the excess return", col.names = c("mean", "sd", "min", "Q1", "median", "Q3", "max")) %>% 
  kable_paper("hover", full_width = T) %>% 
  kable_styling(latex_options = "HOLD_position")

```

We see that on average an equally weighted portfolio with all assets in our investment universe would have generated a `r round(as.numeric(summary1[1,1])*100,2)`% monthly excess return. We also see that on average the 25% worst performing stocks (Q1) have generated a negative excess return of `r round(as.numeric(summary1[1,4])*100,2)`% or worse, while the 25% best performing stocks (Q3) have generated an excess return of `r round(as.numeric(summary1[1,6])*100,2)`% or more. Furthermore, we see that the mean and the median are fairly close to each other which indicates a symmetrical distribution for the excess return.

### Exercise 2

When trying to find the optimal portfolio, it can be important to include transaction cost when rebalancing since this obviously affects the return. If the cost of rebalancing the portfolio outweighs the expected gained excess return from the new portfolio, then it would be more efficient to keep the original portfolio. We can therefore look at the following portfolio choice problem for transaction-cost[^1]:
\begin{align}
    \omega_{t+1}^{*}=\arg \max _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \omega^{\prime} \mu-\nu_{t}\left(\omega, \omega_{t^{+}}, \lambda\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega 
\label{eq:1} 
\end{align}

In this assignment, we assume that transaction costs are quadratic in rebalancing and proportional
to the amount of risk, e.g., $TC\left(\omega,\omega_{t^+}\right) = \lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)$. $\lambda \in R_{+}$ is a cost parameter and $\omega_{t^+} := \frac{\omega_t \circ \left(1+r_t\right)}{\iota^{\prime}\left(\omega_t \circ \left(1+r_t\right)\right)}$ is the weight vector before rebalancing. $\circ$ denotes element-wise
multiplication. By inserting $TC\left(\omega,\omega_{t^+}\right)$ into \eqref{eq:1}, we get the following maximization problem[^2]:
\begin{align}
    \omega_{t+1}^{*}=\arg \max _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \omega^{\prime} \mu-\lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega 
\label{eq:2} 
\end{align}

In order to find a closed form solution, we start by rewriting the function to be maximized in equation \eqref{eq:2} as follows (the constant $\omega_{t^+}^{\prime}\Sigma\omega_{t^+}$ will be ignored, since it doesn't affect the optimal portfolio choice. So technically the equal sign is not true, but for this purpose it is fine):
\begin{align*}
     & \omega^{\prime} \mu-\lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \mu-\lambda\left(\omega^{\prime}\Sigma\omega - 2\omega^{\prime}\Sigma\omega_{t^+} + \underset{\text{constant}}{\omega_{t^+}^{\prime}\Sigma\omega_{t^+}}\right) -\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \mu-\lambda\left(\omega^{\prime}\Sigma\omega - 2\omega^{\prime}\Sigma\omega_{t^+}\right) -\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \left(\mu + 2\lambda \Sigma \omega_{t^+}\right) - \frac{\gamma}{2} \omega^{\prime} \left(\Sigma + \frac{2\lambda}{\gamma}\Sigma\right)\omega \\
     &= \omega^{\prime} \left(\mu + 2\lambda \Sigma \omega_{t^+}\right) - \frac{\gamma}{2}\left(\frac{\gamma + 2\lambda\right}{\gamma}) \omega^{\prime}\Sigma\omega \\
     &= \omega^{\prime} \mu^{*} - \frac{\gamma}{2} \omega^{\prime}\Sigma^{*}\omega 
\end{align*}

Where we have defined and used that $\mu^{*}=\mu + 2\lambda \Sigma \omega_{t^+}$ and $\Sigma^{*}=\left(\frac{\gamma + 2\lambda\right)\Sigma$. We can now use this to find a closed-form solution. Maximizing a function is the same as minimizing the negative function:
\begin{align}
    \omega_{t+1}^{*}=\arg \min _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \frac{\gamma}{2} \omega^{\prime} \Sigma^{*} \omega - \omega^{\prime} \mu^{*}
\label{eq:3} 
\end{align}

[^1]: We assume that $\beta$ is a mistake and that it should in fact have been $\lambda$: $\nu_t(\omega,\omega_{t^+},\gamma)$.
[^2]: We assume that $\nu_t(\omega,\omega_{t^+},\beta)$ and $TC(\omega,\omega_{t^+})$ are equal to each other, since we otherwise don't have a function for $\nu_t$.

In order to find a closed-form solution, we define the Lagrangian, differentiate it with respect to $\omega$ and $\lambda$ and then solve for $\omega$ (using that $\Sigma^{*}$ is symmetric):
\begin{equation*}
    \mathcal{L}\left(\mathbf{\omega}, \lambda\right) = \frac{\gamma}{2} \omega^{\prime} \Sigma^{*} \omega - \omega^{\prime} \mu^{*} + \lambda\left(\iota^{\prime}\omega - 1\right)
\end{equation*}
\begin{align*}
    \frac{\partial\mathcal{L}\left(\mathbf{\omega}, \lambda\right)}{\partial\omega} = \frac{\gamma}{2}\left(\Sigma^{*}+\left(\Sigma^{*}\right)^{\prime}\right)\omega - \mu^{*} + \lambda\iota &= \gamma\Sigma^{*}\omega - \mu^{*} + \lambda\iota = 0
\end{align*}
\begin{align}
    \Leftrightarrow \gamma\Sigma^{*}\omega &= \mu^{*} - \lambda\iota \notag\\
    \Leftrightarrow \omega &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \iota^{\prime}\omega &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right)
\label{eq:4}
\end{align}
\begin{align}
    \frac{\partial\mathcal{L}\left(\mathbf{\omega}, \lambda\right)}{\partial\lambda} = \iota^{\prime}\omega - 1 = 0 \quad \Leftrightarrow \quad \iota^{\prime}\omega = 1
\label{eq:5}
\end{align}
Equating \eqref{eq:4} and \eqref{eq:5} and solve for $\lambda$:
\begin{align}
    1 &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota &= \iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma \notag\\
    \lambda &= \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)
\label{eq:6}
\end{align}
Inserting \eqref{eq:6} in \eqref{eq:4} results in the following closed-form solution:
\begin{align}
    \iota^{\prime}\omega &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \Leftrightarrow \omega &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1}\mu^{*} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    &= \frac{1}{\gamma}\left(\gamma\frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota + \left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*}\right) \notag\\
    &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*} + \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota
\label{eq:7}
\end{align}
By using $\mu^{*}$ and $\Sigma^{*}$ we have now found the closed-form solution in \eqref{eq:7}, which is just the closed-form solution for the standard mean-variance portfolio optimization problem. By inserting $\mu^{*}$ and $\Sigma^{*}$ into this, we get the closed-form solution for the portfolio choice problem with transaction-cost:
\begin{equation*}
    \omega_{t+1}^{*} = \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*} + \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota
\end{equation*}


```{r excersise 2: compute optimal weights, echo=FALSE}
# Function that computes the optimal weights
optimal_weights <- function(w_prev, mu, Sigma, lambda, gamma = gamma_default){
  N <- ncol(Sigma)
  iota <- rep(1, N)
 
  #Define mu_star and sigma_star according to the previously found close form solution 
  mu_star <- mu + 2 * lambda * Sigma %*% w_prev # Cost-adjusted mu
  Sigma_star <- (gamma + 2 * lambda) / gamma * Sigma # Cost-adjusted sigma
  
  # Invert Sigma 
  Sigma_inv <- solve(Sigma_star) 
  
  # Calculates the optimal portfolio weights
  w_mvp <- Sigma_inv %*% iota
  w_mvp <- w_mvp / sum(w_mvp)
  w_opt <- w_mvp  + 1/gamma * (Sigma_inv - w_mvp %*% t(iota) %*% Sigma_inv) %*% mu_star
  return(w_opt)
}


```

We now use this closed-form solution in order to find the optimal portfolio weights. We start by calculating the sample $\mu$ and $\Sigma$ in the standard ways where $\hat{\mu}$ is found as the mean of the excess return for each stock over the whole sample period and $\hat{\Sigma}$ is found by creating a matrix of all the excess returns for all stocks for each month and then finding the covariance of these returns. We also compute the naive portfolio, which we will use as $\omega_{t^+}$ in the closed-form solution. Since we are interested in understanding how transaction cost affects optimal portfolio choice, we now do the following steps:
1. Firstly, we create a vector of different values of $\lambda$ along with computing the efficient portfolio in the case of no transaction cost $\omega_{\gamma=4}\left(\hat{\mu},\hat{\Sigma}\right)$. In this assignment we have chosen the vector of $\lambda$-values to range from 0 to 100.
2. Secondly, for each value of $\lambda$ we find the optimal portfolio weights using the closed-form solution (and the fact that we start in the naive portfolio). When we have found the optimal weights, we find the absolute difference for these weights compared to the weights of the efficient portfolio without transaction cost. We then sum all these differences of the portfolio weights and store this for later.
3. Lastly, we plot all the differences for the respective values of $\lambda$. This is the plot which is shown below.

```{r excersise 2: compute sample mean and variance-covariance matrix and distance between optimal portfolio weights, echo=FALSE}

# Computes sample mean excess return
mu <- (crsp_monthly_reduced %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess

# Computes sample variance-covariance matrix
stocks <- unique(crsp_monthly_reduced$permno)
returns <- matrix(ncol = length(stocks), nrow = n_months)
colnames(returns) <- stocks
for(i in 1:length(stocks)){
  returns[,i] <- (crsp_monthly_reduced %>% filter(permno == stocks[i]))$ret_excess
}
Sigma <- returns %>% cov() %>% as.matrix()

# Creates the naive portfolio
naive <- 1/ncol(Sigma) * rep(1, ncol(Sigma))

# Creates a vector with different values of lambda
lambda_vector <- c(0:100)

# Computes the efficient portfolio without transaction costs
efficient_no_trans <- optimal_weights(w_prev = naive, mu, Sigma, lambda = 0)

# Creates a vector in order to save the distance between the portfolios with and without transaction cost
dist <- rep(data = NA, length(lambda_vector))

# Loops through the different values of lambda and calculates the distance between the portfolios
for(i in 1:length(lambda_vector)){
  optimal_with_trans <- optimal_weights(w_prev = naive, mu, Sigma, lambda = lambda_vector[i])
  dist[i] <- sum(abs(optimal_with_trans - efficient_no_trans))
}

# Creating a plot of the distance between portfolio weights
as.data.frame(cbind(lambda_vector, dist)) %>%
  ggplot(aes(x = lambda_vector, y = dist)) + 
  geom_line(color="darkorchid",size=1.2) +
  #scale_x_sqrt() +
  labs(x = "Transaction cost parameter", 
       y = "Distance from the optimal portfolio without transaction cost",
       title = "Distance between optimal portfolio weights for different transaction costs") +
  theme_bw()


```

The shape of the curve is what we would expect in this setup. With a transaction cost of 0 the optimal portfolio is perfectly rebalanced to match the efficient portfolio (which is defined as having no transaction cost). As transaction cost increases the distance converges towards the distance between the naive portfolio and the efficient portfolio. This makes perfect sense, because when transaction cost gets too high the investor simply sticks with the naive portfolio as it becomes impossible to generate an extra excess return large enough to compensate for the cost of moving away from the naive portfolio.


### Excercise 3


```{r excersise 3: Backtesting, echo=FALSE}
#Prepare vectors that contain results
N<-nrow(Sigma)
months<-sort(unique(crsp_monthly_reduced$month))   #Overflødig
periods<-n_months-window_length #Number of periods
NP_return<-rep(0,periods)
HEA_return<-rep(0,periods)
NSS_return<-rep(0,periods)

NP_turnover<-rep(0,periods)
HEA_turnover<-rep(0,periods)
NSS_turnover<-rep(0,periods)

NP_TC<-rep(0,periods)
HEA_TC<-rep(0,periods)
NSS_TC<-rep(0,periods)

# Define function to determine no short sell optimal portfolio
 No_short_sale_weight <- function(mu,
                                          Sigma,
                                          gamma = gamma_default){
   N <- ncol(Sigma)
   A <- diag(N)
   out <- quadprog::solve.QP(Dmat = gamma * Sigma,
                             dvec = mu,
                             Amat = A,
                             bvec = c(rep(0, N)),
                             meq = 1)
   return(as.numeric(out$solution))
 }
 

for(i in 1:periods){ #Begin for loop for monthly portfolio estimation

  if(i>1){ 
    #Calculate development in lagged portfolio
    NP_lagged_developed<-NP_lagged*(1+r)/as.numeric(1+t(NP_lagged)%*%r)
    HEA_lagged_developed<-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)
    NSS_lagged_developed<-NSS_lagged*(1+r)/as.numeric(1+t(NSS_lagged)%*%r)
  } else{
    HEA_lagged<-rep(1/N,N)
  }
  
  #Chosse the part of the data frame that matches our window
  crsp_monthly_reduced_tmp<-crsp_monthly_reduced %>% filter(month>=months[i]) %>% filter(month<months[i+window_length])
  # Computes sample mean excess return
  mu_hat <- (crsp_monthly_reduced_tmp %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess
  
  # Generate a vector with returns for current month
  r<-((crsp_monthly_reduced %>% filter(month == months[i+window_length]))$ret_excess)

  # Computes sample variance-covariance matrix
  stocks <- unique(crsp_monthly_reduced$permno)
  returns <- matrix(ncol = length(stocks), nrow = window_length)
  colnames(returns) <- stocks
  for(j in 1:length(stocks)){
    returns[,j] <- (crsp_monthly_reduced_tmp %>% filter(permno == stocks[j]))$ret_excess
  }
  
  Sigma_hat <- returns %>% cov() %>% as.matrix()

  #Calculate portfolio weights

  #Naive portfolio
   NP<-rep(1/N,N)
   NP_return_tmp<-t(NP) %*% r
  # Hautsch et al. portfolio
    HEA<-optimal_weights(HEA_lagged,mu_hat,Sigma_hat,lambda)
    HEA_return_tmp<-t(HEA) %*% r
  # Jagannathan portfolion
    NSS<-No_short_sale_weight(mu_hat,Sigma_hat)
    NSS_return_tmp<-t(NSS) %*% r

  if(i>1){ 

    #calculate Transaction cost and turnover. Save them
    NP_turnover[i]<- sqrt(t(NP-NP_lagged_developed) %*% (NP-NP_lagged_developed))
    HEA_turnover[i]<- sqrt(t(HEA-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)) %*% (HEA-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)))
    NSS_turnover[i]<- sqrt(t(NSS-NSS_lagged_developed) %*% (NSS-NSS_lagged_developed))

    # Calculate transaction cost
    NP_TC[i]<- lambda %*% t(NP-NP_lagged_developed)%*% Sigma_hat %*% (NP-NP_lagged_developed)
    HEA_TC[i]<- lambda %*% t(HEA - HEA_lagged)%*% Sigma_hat %*% (HEA - HEA_lagged)
    NSS_TC[i]<- lambda %*% t(NSS - NSS_lagged_developed)%*% Sigma_hat %*% (NSS - NSS_lagged_developed)
    
    #Calculate returns adjusted for transaction cost
    NP_return[i]<-as.numeric(NP_return_tmp)-NP_TC[i]
    HEA_return[i]<-as.numeric(HEA_return_tmp)-HEA_TC[i]
    NSS_return[i]<-as.numeric(NSS_return_tmp)-NSS_TC[i]
    }

  #Save portolio weigths lagged for turnover calculation in next month  
  NP_lagged<-NP
  HEA_lagged<-HEA
  NSS_lagged<-NSS
     
} #End loop

#Average turnover

#Sharpe ratio
NP_SR<-mean(NP_return)/sqrt(1/(periods-1)*sum((NP_return-mean(NP_return))^2))
HEA_SR<-mean(HEA_return)/sqrt(1/(periods-1)*sum((HEA_return-mean(HEA_return))^2))
NSS_SR<-mean(NSS_return)/sqrt(1/(periods-1)*sum((NSS_return-mean(NSS_return))^2))

#Generates a matrix with the results to display them.
Turnover_SR<-matrix(c(mean(NP_return),sd(NP_return),mean(NP_turnover),sd(NP_turnover),NP_SR,
                      mean(HEA_return),sd(HEA_return),mean(HEA_turnover),sd(HEA_turnover),HEA_SR,
                      mean(NSS_return),sd(NSS_return),mean(NSS_turnover),sd(NSS_turnover),NSS_SR),
                      ncol = 3)
#Adds row and column names
colnames(Turnover_SR)<-c("NP","HEA","NSS")
rownames(Turnover_SR)<-c("Average return","Return standard deviation","Average Turnover","Turnover standard deviation", "Sharpe ratio")
#Prints the table
Turnover_SR %>% knitr::kable() %>% kable_paper("hover", full_width = T)

```
NP is the naive portfolio, HAE is the Hautsch et al. portfolio and NSS is the no short sale portfolio.


The no short portfolio performed the best with a 1.5% average monthly return. The naive portfolio performed amazingly well  taking its simplicity into account with a 0.9% monthly return. The transaction cost optimized portfolio had a really poor performance with an average monthly loss of 11%.

We would not describe this as a "true" out of sample experiment. The used rolling window strategy has similarities with a out of sample experiment. In a way it is a series of smaller out of sample experiments, but we always only predict one month ahead which means the portion of data that is picked to be "out of sample" is really small.





```{r excersise 3: Sandbox, echo=FALSE}

#window_length <- 120 
periods<-n_months-window_length #Number of periods
months<-sort(unique(crsp_monthly_reduced$month))
stocks <- unique(crsp_monthly_reduced$permno)
#periods <- nrow(industry_returns) - window_length 


#beta <- 50
#gamma <- 2

performance_values <- matrix(NA, 
                             nrow = periods, 
                             ncol = 3) # A matrix to collect all returns
colnames(performance_values) <- c("raw_return", "turnover", "net_return") 

performance_values <- list("Mean_Var_(TC)" = performance_values, 
                           "Naive" = performance_values, 
                           "No_short_sale" = performance_values)

w_prev_1 <- w_prev_2 <- w_prev_3 <- rep(1 /nrow(stocks_traded), nrow(stocks_traded))


#######################################################################


# Define function to adjust weights after returns have been realized
adjust_weights <- function(w, next_return){
  w_prev <- 1 + w * next_return
  as.numeric(w_prev / sum(as.vector(w_prev)))
}

# Define function to evaluate performance before and after transaction cost
evaluate_performance <- function(w, w_previous, next_return, lambda){
  raw_return <- as.numeric(t(as.matrix(next_return)) %*% w)
  turnover <- sum(abs(w - w_previous))
  net_return <- raw_return - lambda * turnover
  c(raw_return, turnover, net_return)
}

# Define function to determine no short sell optimal portfolio
 No_short_sale_weight <- function(mu,
                                          Sigma,
                                          gamma = gamma_default){
   N <- ncol(Sigma)
   A <- diag(N)
   out <- quadprog::solve.QP(Dmat = gamma * Sigma,
                             dvec = mu,
                             Amat = A,
                             bvec = c(rep(0, N)),
                             meq = 1)
   return(as.numeric(out$solution))
 }
#######################################################################



for(i in 1:periods){
  
  returns_window <- crsp_monthly_reduced %>% filter(month >= months[i]) %>% filter(month < months[i+window_length])
  
  
  #returns_window <- industry_returns[i : (i + window_length - 1), ]
  # next_return <- industry_returns[i + window_length, ] 
  next_return <- (crsp_monthly_reduced %>% filter(month == months[i+window_length]) %>% select(ret_excess))$ret_excess
  
  # Computes sample mean excess return
  mu_hat <- (returns_window %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess
  
  # Computes sample variance-covariance matrix
  returns <- matrix(ncol = length(stocks), nrow = window_length)
  colnames(returns) <- stocks
  for(j in 1:length(stocks)){
    returns[,j] <- (returns_window %>% filter(permno == stocks[j]))$ret_excess
  }
  Sigma_hat <- returns %>% cov() %>% as.matrix()
  
  # Sigma_hat <- cov(returns_window) 
  # mu <- 0 * colMeans(returns_window) 
  
  # Transaction-cost adjusted portfolio
  # w_1 <- compute_efficient_weight_L1_TC(mu = mu_hat, 
  #                                       Sigma = Sigma_hat, 
  #                                       lambda = lambda, 
  #                                       gamma = gamma,
  #                                       w_prev = w_prev_1)
  
  
  # (w_prev, mu, Sigma, lambda, gamma = gamma_default)
  
  w_1 <-optimal_weights(w_prev_1, mu_hat, Sigma_hat, lambda, gamma_default)

  performance_values[[1]][i, ] <- evaluate_performance(w_1, 
                                                       w_prev_1, 
                                                       next_return, 
                                                       lambda = lambda)
  
  w_prev_1 <- adjust_weights(w_1, next_return)
  
  # Naive portfolio
  w_2 <- rep(1 /nrow(stocks_traded), nrow(stocks_traded))
  
  performance_values[[2]][i, ] <- evaluate_performance(w_2, 
                                                       w_prev_2, 
                                                       next_return,
                                                       lambda = lambda)
  
  w_prev_2 <- adjust_weights(w_2, next_return)
  
  # No short sale portfolio
  w_3 <- No_short_sale_weight(mu_hat,Sigma_hat)
  
  performance_values[[3]][i, ] <- evaluate_performance(w_3, 
                                                       w_prev_3, 
                                                       next_return,
                                                       lambda = lambda)
  
  w_prev_3 <- adjust_weights(w_3, next_return)
}



#######################################################################



performance <- lapply(performance_values, as_tibble) %>% 
  bind_rows(.id = "strategy")

performance %>%
  group_by(strategy) %>% summarise(across(c(raw_return,turnover,net_return), list(mean=mean,sd=sd)))






# Generates an empty data frame, assigns columns for summary statistics and loads a vector with the variables we wish to summarise
summary1 <- data.frame(matrix(ncol=3, nrow=3)) #There are 7 summary statistics and two variables
colnames(summary1) <- c("mean", "sd", "min", "Q1","median", "Q3", "max")
var_names<- c("raw_return","turnover","net_return")

# Loops through all the chosen variables and calculates mean, sd, min, Q1, median, Q3 and max for each month then takes the average of those results.  
for(i in 1:2){  
summary1[i,] <- crsp_monthly %>%
    group_by(month) %>%
  summarise(across(var_names[i],
                   list(mean = mean, 
                        sd = sd, 
                        min = min,
                        q25 = ~quantile(., 0.25),
                        median = median,
                        q75 = ~quantile(., 0.75), 
                        max = max),
                   .names = "{.fn}  ")) %>%
  summarise(across(-month, mean))
}

#Assigns relevant row names
rownames(summary1) <- c("Excess return", "Market cap")

# Rounding the excess return values to 4 for the output
summary1[1,] <- round(summary1[1,], 4)

# Rounding the market cap values (since they are so large that decimals have no real significance)
summary1[2,c(1:2, 4:7)] <- round(summary1[2,c(1:2, 4:7)], 0)

#Prints the summary nicely in a table
summary1 %>% knitr::kable(booktabs = T, digits = 4, caption = "Summary statistics of the excess return and the market cap") %>% 
  kable_paper("hover", full_width = T) %>% 
  kable_styling(latex_options = "HOLD_position")






  # summarize(Mean = 12 * mean(100 * net_return),
  #           SD = sqrt(12) * sd(100 * net_return), 
  #           `Sharpe ratio` = if_else(Mean > 0, Mean / SD, NA_real_),
  #           Turnover = 100 * mean(turnover))








```