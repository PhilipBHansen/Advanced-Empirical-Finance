---
title: "AEF Mandatory Assignment 3"
author: "Alexander Mogensen, Mie Schjerling and Philip Hansen"
date: "7/5/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

########################
### BEGIN USER INPUT ###
######################## 

# Automatic setup for working directory for authors of this file
tmp <- getwd()
if(substr(tmp,1,12) == "C:/Users/Mie"){
  # Mie
  setwd("C:/Users/Mie/OneDrive/CBS/Kandidat/data")
} else if(substr(tmp,1,14) == "C:/Users/Alexm"){
  # Alexander
  setwd("C:/Users/Alexm/Documents")
} else{
  # Philip
  setwd("C:/Users/phili/OneDrive - CBS - Copenhagen Business School/Desktop/Code/R - code/AEF")
}

gamma_default <- 4
window_length<-240
lambda<-200/10000

######################
### END USER INPUT ###
######################


# Load packages
library(lubridate)
library(sandwich)
library(lmtest)
library(RSQLite)
library(tidyverse)
library(tidymodels)
library(furrr)
library(glmnet)
library(broom)
library(timetk)
library(scales)
library(keras)
library(hardhat)
library(kableExtra)
library(data.table)
library(ranger)

# Changes decimals from having e to having 0s
options(scipen = 999)

# Loading data
tidy_finance <- dbConnect(SQLite(), "tidy_finance.sqlite", extended_types = TRUE) # Connect to sql
crsp_monthly <- tbl(tidy_finance, "crsp_monthly") %>% collect() %>% select("permno", "date", "month", "ret", "mktcap", "mktcap_lag", "industry", "ret_excess")

```

```{r Exercise 1 data filtering, echo=FALSE}
# Filtering on desired time interval for uninterrupted stocks
crsp_monthly_reduced <- crsp_monthly %>% 
  filter(month >= "1962-01-01") %>% 
  filter(month <= "2019-12-01") 

stocks_traded <- crsp_monthly_reduced %>% 
  group_by(permno) %>% 
  summarise(n=n())

n_months <- length(unique(crsp_monthly_reduced$month))

stocks_traded <- stocks_traded %>% filter(n == n_months)

crsp_monthly_reduced <- crsp_monthly_reduced %>%
  filter(permno %in% stocks_traded$permno)

```

The data used for this assignment is collected from the CRSP universe and consists of data from 1962 until 2020. We only select the stocks that are traded each month during this time period. This is done by counting the number of months in this interval, counting the number of times each stock (permno) is traded and then filtering on the stocks that are traded the same amount of times as there exists of month (which for this interval is `r n_months`). This results in an investment universe consisting of 119 stocks. We then create the following summary of the excess return by finding the cross-sectional values for each month and then averaging over all month:

```{r Exercise 1 summary, echo=FALSE}
# Creating summary statistics
summary1 <- crsp_monthly_reduced %>%
  group_by(month) %>%
  summarise(across(ret_excess, #Creating list of summarize statistics
                   list(mean = mean, sd = sd, min = min,
                        q25 = ~quantile(., 0.25),
                        median = median,
                        q75 = ~quantile(., 0.75), max = max),
                   .names = "{.fn} excess_ret")) %>% #Adds the name to every element in the list
  summarise(across(-month, mean)) 

row.names(summary1) <- "Excess return"

summary1 %>%
  knitr::kable(booktabs = T, digits = 4, caption = "Summary statistics of the excess return", col.names = c("mean", "sd", "min", "Q1", "meadian", "Q3", "max")) %>% 
  kable_paper("hover", full_width = T) %>% 
  kable_styling(latex_options = "HOLD_position")

```

We see that on average a equally weighted portfolio with all assets in our investment universe would have generated a 0.78% monthly return. We also see that on average the 25% worst performing stocks have generated a negative excess return of -3.38% or worse. While the 25% best performing stocks have generated a excess return of 4.57% or more.

### Exercise 2

When trying to find the optimal portfolio, it can be important to include transaction cost when rebalancing since this obviously affect the return. If the cost of rebalancing the portfolio outweighs the expected excess return from the new portfolio, then it would be more efficient to keep the original portfolio. We can therefore look at the following portfolio choice problem for transaction-cost[^1]:
\begin{align}
    \omega_{t+1}^{*}=\arg \max _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \omega^{\prime} \mu-\nu_{t}\left(\omega, \omega_{t^{+}}, \lambda\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega 
\label{eq:1} 
\end{align}

In this assignment, we assume that transaction costs are quadratic in rebalancing and proportional
to the amount of risk, e.g., $TC\left(\omega,\omega_{t^+}\right) = \lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)$. $\lambda \in R_{+}$ is a cost parameter and $\omega_{t^+} := \frac{\omega_t \circ \left(1+r_t\right)}{\iota^{\prime}\left(\omega_t \circ \left(1+r_t\right)\right)}$ is the weight vector before rebalancing. $\circ$ denotes element-wise
multiplication. By inserting $TC\left(\omega,\omega_{t^+}\right)$ into \eqref{eq:1}, we get the following maximization problem[^2]:
\begin{align}
    \omega_{t+1}^{*}=\arg \max _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \omega^{\prime} \mu-\lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega 
\label{eq:2} 
\end{align}

In order to find a closed form solution, we start by rewriting the function to be maximized in equation \eqref{eq:2} as follows (the constant $\omega_{t^+}^{\prime}\Sigma\omega_{t^+}$ will be ignored, since it doesn't affect the optimal portfolio choice. So technically the equal sign is not true, but for this purpose it is fine):
\begin{align*}
     & \omega^{\prime} \mu-\lambda\left(\omega - \omega_{t^+}\right)^{\prime} \Sigma \left(\omega - \omega_{t^+}\right)-\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \mu-\lambda\left(\omega^{\prime}\Sigma\omega - 2\omega^{\prime}\Sigma\omega_{t^+} + \underset{\text{constant}}{\omega_{t^+}^{\prime}\Sigma\omega_{t^+}}\right) -\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \mu-\lambda\left(\omega^{\prime}\Sigma\omega - 2\omega^{\prime}\Sigma\omega_{t^+}\right) -\frac{\gamma}{2} \omega^{\prime} \Sigma \omega \\
     &= \omega^{\prime} \left(\mu + 2\lambda \Sigma \omega_{t^+}\right) - \frac{\gamma}{2} \omega^{\prime} \left(\Sigma + \frac{2\lambda}{\gamma}\Sigma\right)\omega \\
     &= \omega^{\prime} \left(\mu + 2\lambda \Sigma \omega_{t^+}\right) - \frac{\gamma}{2}\left(\gamma + 2\lambda\right) \omega^{\prime}\Sigma\omega \\
     &= \omega^{\prime} \mu^{*} - \frac{\gamma}{2} \omega^{\prime}\Sigma^{*}\omega 
\end{align*}

Where we have defined and used that $\mu^{*}=\mu + 2\lambda \Sigma \omega_{t^+}$ and $\Sigma^{*}=\left(\frac{\gamma + 2\lambda}{\gamma}\right)\Sigma$. We can now use this to find a closed-form solution. To maximize a function is the same as minimizing the negative function:
\begin{align}
    \omega_{t+1}^{*}=\arg \min _{\omega \in \mathbb{R}^{N}, \iota^{\prime} \omega=1} \frac{\gamma}{2} \omega^{\prime} \Sigma^{*} \omega - \omega^{\prime} \mu^{*}
\label{eq:3} 
\end{align}

[^1]: We assume that $\beta$ is a mistake and that it should in fact have been $\lambda$: $\nu_t(\omega,\omega_{t^+},\gamma)$.
[^2]: We assume that $\nu_t(\omega,\omega_{t^+},\beta)$ and $TC(\omega,\omega_{t^+})$ are equal to each other, since we otherwise don't have a function for $\nu_t$.

In order to find a closed-form solution, we define the Lagrangian, differentiate it with respect to $\omega$ and $\lambda$ and then solve for $\omega$ (using that $\Sigma^{*}$ is symmetric):
\begin{equation*}
    \mathcal{L}\left(\mathbf{\omega}, \lambda\right) = \frac{\gamma}{2} \omega^{\prime} \Sigma^{*} \omega - \omega^{\prime} \mu^{*} + \lambda\left(\iota^{\prime}\omega - 1\right)
\end{equation*}
\begin{align*}
    \frac{\partial\mathcal{L}\left(\mathbf{\omega}, \lambda\right)}{\partial\omega} = \frac{\gamma}{2}\left(\Sigma^{*}+\left(\Sigma^{*}\right)^{\prime}\right)\omega - \mu^{*} + \lambda\iota &= \gamma\Sigma^{*}\omega - \mu^{*} + \lambda\iota = 0
\end{align*}
\begin{align}
    \Leftrightarrow \gamma\Sigma^{*}\omega &= \mu^{*} - \lambda\iota \notag\\
    \Leftrightarrow \omega &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \iota^{\prime}\omega &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right)
\label{eq:4}
\end{align}
\begin{align}
    \frac{\partial\mathcal{L}\left(\mathbf{\omega}, \lambda\right)}{\partial\lambda} = \iota^{\prime}\omega - 1 = 0 \quad \Leftrightarrow \quad \iota^{\prime}\omega = 1
\label{eq:5}
\end{align}
Equating \eqref{eq:4} and \eqref{eq:5} and solve for $\lambda$:
\begin{align}
    1 &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \lambda\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota &= \iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma \notag\\
    \lambda &= \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)
\label{eq:6}
\end{align}
Inserting \eqref{eq:6} in \eqref{eq:4} results in the following closed-form solution:
\begin{align}
    \iota^{\prime}\omega &= \frac{1}{\gamma}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    \Leftrightarrow \omega &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1}\mu^{*} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\mu^{*} - \gamma\right)\left(\Sigma^{*}\right)^{-1}\iota\right) \notag\\
    &= \frac{1}{\gamma}\left(\gamma\frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota + \left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*}\right) \notag\\
    &= \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*} + \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota
\label{eq:7}
\end{align}
By using $\mu^{*}$ and $\Sigma^{*}$ we have now found the closed-form solution in \eqref{eq:7}, which is just the closed-form solution for the standard mean-variance portfolio optimization problem. By inserting $\mu^{*}$ and $\Sigma^{*}$ into this, we get the closed-form solution for the portfolio choice problem with transaction-cost:
\begin{equation*}
    \omega_{t+1}^{*} = \frac{1}{\gamma}\left(\left(\Sigma^{*}\right)^{-1} - \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\left(\Sigma^{*}\right)^{-1}\iota\right)\mu^{*} + \frac{1}{\iota^{\prime}\left(\Sigma^{*}\right)^{-1}\iota}\left(\Sigma^{*}\right)^{-1}\iota
\end{equation*}


```{r excersise 2: compute optimal weights, echo=FALSE}
# Function that computes the optimal weights
optimal_weights <- function(w_prev, mu, Sigma, lambda, gamma = gamma_default){
  N <- ncol(Sigma)
  iota <- rep(1, N)
 
  #Define mu_star and sigma_star according to the previously found close form solution 
  mu_star <- mu + 2 * lambda * Sigma %*% w_prev # Cost-adjusted mu
  Sigma_star <- (gamma + 2 * lambda) / gamma * Sigma # Cost-adjusted sigma
  
  Sigma_inv <- solve(Sigma_star) # invert Sigma 
  
  # Calculates the optimal portfolio weights
  w_mvp <- Sigma_inv %*% iota
  w_mvp <- w_mvp / sum(w_mvp)
  w_opt <- w_mvp  + 1/gamma * (Sigma_inv - w_mvp %*% t(iota) %*% Sigma_inv) %*% mu_star
  return(w_opt)
}

```

```{r excersise 2: compute sample mean and variance-covariance matrix, echo=FALSE}

# Computes sample mean excess return
mu <- (crsp_monthly_reduced %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess



# Computes sample variance-covariance matrix
stocks <- unique(crsp_monthly_reduced$permno)
returns <- matrix(ncol = length(stocks), nrow = n_months)
colnames(returns) <- stocks
for(i in 1:length(stocks)){
  returns[,i] <- (crsp_monthly_reduced %>% filter(permno == stocks[i]))$ret_excess
}

Sigma <- returns %>% cov() %>% as.matrix()


```



```{r excersise 3: Backtesting, echo=FALSE}
#Prepare vectors that contain results
N<-nrow(Sigma)
months<-sort(unique(crsp_monthly_reduced$month))
periods<-n_months-window_length #Number of periods
NP_return<-rep(0,periods)
HEA_return<-rep(0,periods)
NSS_return<-rep(0,periods)

NP_turnover<-rep(0,periods)
HEA_turnover<-rep(0,periods)
NSS_turnover<-rep(0,periods)

NP_TC<-rep(0,periods)
HEA_TC<-rep(0,periods)
NSS_TC<-rep(0,periods)

# Define function to determine no short sell optimal portfolio
 No_short_sale_weight <- function(mu,
                                          Sigma,
                                          gamma = gamma_default){
   N <- ncol(Sigma)
   A <- diag(N)
   out <- quadprog::solve.QP(Dmat = gamma * Sigma,
                             dvec = mu,
                             Amat = A,
                             bvec = c(rep(0, N)),
                             meq = 1)
   return(as.numeric(out$solution))
 }
 

for(i in 1:periods){ #Begin for loop for monthly portfolio estimation

  if(i>1){ 
    #Calculate development in lagged portfolio
    NP_lagged_developed<-NP_lagged*(1+r)/as.numeric(1+t(NP_lagged)%*%r)
    HEA_lagged_developed<-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)
    NSS_lagged_developed<-NSS_lagged*(1+r)/as.numeric(1+t(NSS_lagged)%*%r)
  } else{
    HEA_lagged<-rep(1/N,N)
  }
  
  #Chosse the part of the data frame that matches our window
  crsp_monthly_reduced_tmp<-crsp_monthly_reduced %>% filter(month>=months[i]) %>% filter(month<months[i+window_length])
  # Computes sample mean excess return
  mu_hat <- (crsp_monthly_reduced_tmp %>%
  group_by(permno) %>%
  summarise(across(ret_excess, mean)))$ret_excess
  
  # Generate a vector with returns for current month
  r<-((crsp_monthly_reduced %>% filter(month == months[i+window_length]))$ret_excess)

  # Computes sample variance-covariance matrix
  stocks <- unique(crsp_monthly_reduced$permno)
  returns <- matrix(ncol = length(stocks), nrow = window_length)
  colnames(returns) <- stocks
  for(j in 1:length(stocks)){
    returns[,j] <- (crsp_monthly_reduced_tmp %>% filter(permno == stocks[j]))$ret_excess
  }
  
  Sigma_hat <- returns %>% cov() %>% as.matrix()

  #Calculate portfolio weights

  #Naive portfolio
   NP<-rep(1/N,N)
   NP_return_tmp<-t(NP) %*% r
  # Hautsch et al. portfolio
    HEA<-optimal_weights(HEA_lagged,mu_hat,Sigma_hat,lambda)
    HEA_return_tmp<-t(HEA) %*% r
  # Jagannathan portfolion
    NSS<-No_short_sale_weight(mu_hat,Sigma_hat)
    NSS_return_tmp<-t(NSS) %*% r

  if(i>1){ 

    #calculate Transaction cost and turnover. Save them
    NP_turnover[i]<- sqrt(t(NP-NP_lagged_developed) %*% (NP-NP_lagged_developed))
    HEA_turnover[i]<- sqrt(t(HEA-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)) %*% (HEA-HEA_lagged*(1+r)/as.numeric(1+t(HEA_lagged)%*%r)))
    NSS_turnover[i]<- sqrt(t(NSS-NSS_lagged_developed) %*% (NSS-NSS_lagged_developed))

    # Calculate transaction cost
    NP_TC[i]<- lambda %*% t(NP-NP_lagged_developed)%*% Sigma_hat %*% (NP-NP_lagged_developed)
    HEA_TC[i]<- lambda %*% t(HEA - HEA_lagged)%*% Sigma_hat %*% (HEA - HEA_lagged)
    NSS_TC[i]<- lambda %*% t(NSS - NSS_lagged_developed)%*% Sigma_hat %*% (NSS - NSS_lagged_developed)
    
    #Calculate returns adjusted for transaction cost
    NP_return[i]<-as.numeric(NP_return_tmp)-NP_TC[i]
    HEA_return[i]<-as.numeric(HEA_return_tmp)-HEA_TC[i]
    NSS_return[i]<-as.numeric(NSS_return_tmp)-NSS_TC[i]
    }

  #Save portolio weigths lagged for turnover calculation in next month  
  NP_lagged<-NP
  HEA_lagged<-HEA
  NSS_lagged<-NSS
     
} #End loop

#Average turnover

#Sharpe ratio
NP_SR<-mean(NP_return)/sqrt(1/(periods-1)*sum((NP_return-mean(NP_return))^2))
HEA_SR<-mean(HEA_return)/sqrt(1/(periods-1)*sum((HEA_return-mean(HEA_return))^2))
NSS_SR<-mean(NSS_return)/sqrt(1/(periods-1)*sum((NSS_return-mean(NSS_return))^2))

#Generates a matrix with the results to display them.
Turnover_SR<-matrix(c(mean(NP_return),sd(NP_return),mean(NP_turnover),sd(NP_turnover),NP_SR,
                      mean(HEA_return),sd(HEA_return),mean(HEA_turnover),sd(HEA_turnover),HEA_SR,
                      mean(NSS_return),sd(NSS_return),mean(NSS_turnover),sd(NSS_turnover),NSS_SR),
                      ncol = 3)
#Adds row and column names
colnames(Turnover_SR)<-c("NP","HEA","NSS")
rownames(Turnover_SR)<-c("Average return","Return standard deviation","Average Turnover","Turnover standard deviation", "Sharpe ratio")
#Prints the table
Turnover_SR %>% knitr::kable() %>% kable_paper("hover", full_width = T)

```
NP is the naive portfolio, HAE is the Hautsch et al. portfolio and NSS is the no short sale portfolio.


The no short portfolio performed the best with a 1.5% average monthly return. The naive portfolio performed amazingly well  taking its simplicity into account with a 0.9% monthly return. The transaction cost optimized portfolio had a really poor performance with an average monthly loss of 11%.

We would not describe this as a "true" out of sample experiment. The used rolling window strategy has similarities with a out of sample experiment. In a way it is a series of smaller out of sample experiments, but we always only predict one month ahead which means the portion of data that is picked to be "out of sample" is really small.












